# 麻雀リポジトリの現状分析と改善案

## 1. はじめに

このドキュメントは、現在の麻雀アプリケーションリポジトリの構造とコードに関する問題点を分析し、MVC（Model-View-Controller）アーキテクチャに基づいた改善案を提案するものです。

## 2. 現状の問題点

現在の実装は、アプリケーションの基本的な動作はするものの、将来的な機能拡張やメンテナンス性においていくつかの課題を抱えています。

### 2.1. 不適切なパッケージ構造

すべてのJavaクラスファイルが `mahjong/src/model/data` という単一のパッケージに配置されています。これにより、各クラスの役割が曖昧になり、コードの見通しが悪くなっています。

- **問題点**:
    - クラスの役割（モデル、ビュー、コントローラー）がパッケージレベルで分離されていない。
    - 新しい機能を追加する際に、どのパッケージにクラスを配置すればよいかが不明確。
    - 全体像の把握が困難。

### 2.2. MVCモデルの原則違反

現在のコードは、MVCの各コンポーネントの責務が分離されていません。特に `Player` クラスと `Main` クラスに問題が見られます。

- **`Player` クラスの問題**:
    - プレイヤーの状態（手牌、点数など）を保持する**モデル**としての役割。
    - プレイヤーのアクション（ツモ、打牌）を定義する**モデル**としての役割。
    - ユーザーからの入力を受け付け、コンソールに情報を出力する**ビュー**および**コントローラー**としての役割。
    - これらがすべて `Player` クラスに混在しており、クラスの責務が肥大化しています。

- **`Main` クラスの問題**:
    - ゲームの開始とメインループを管理する**コントローラー**としての役割。
    - コンソールへのメッセージ表示を行う**ビュー**としての役割。
    - ゲームの初期設定（インスタンス生成）を行うロジックが含まれている。

このような密結合な設計は、以下のような問題を引き起こします。

- **再利用性の低下**: UI（例えば、CUIからGUIへ）を変更したい場合、`Player` クラスなどのモデルロジックにまで手を入れる必要があります。
- **テストの困難さ**: ビジネスロジックとUIロジックが分離されていないため、単体テストが書きにくいです。
- **メンテナンス性の低下**: コードのどこで何が行われているかを理解するのが難しく、修正による影響範囲が広がりがちです。

## 3. 改善案

MVCアーキテクチャを導入し、関心事を分離することで、上記の問題点を解決します。

### 3.1. 新しいパッケージ構造の提案

以下のようなパッケージ構造を提案します。

```
mahjong/
└── src/
    ├── com/
    │   └── example/
    │       └── mahjong/
    │           ├── Main.java             // アプリケーションのエントリポイント
    │           ├── controller/
    │           │   └── GameController.java // ゲームの進行を管理
    │           ├── model/
    │           │   ├── Player.java         // プレイヤーの状態とロジック
    │           │   ├── Table.java          // ゲーム卓の状態
    │           │   ├── Judge.java          // 役判定などのルール
    │           │   ├── TileType.java       // 牌の種類
    │           │   └── ...                 // その他のモデルクラス
    │           └── view/
    │               └── ConsoleView.java    // CUIの表示と入力
    └── test/
        └── ...
```

### 3.2. 各コンポーネントの役割

- **Model**: ゲームのデータとビジネスロジックを担当します。
    - `Player`, `Table`, `TileType`, `Judge` などが該当します。
    - 状態が変化したことを（Observerパターンなどを通じて）Viewに通知しますが、Viewがどのように表示するかは関知しません。
    - `Player` クラスからは、`Scanner` を使った入力受付や `System.out.println` でコンソールに出力する処理を削除します。

- **View**: ユーザーインターフェースを担当します。
    - `ConsoleView` クラスを新設します。
    - Modelから受け取った情報をユーザーに表示する責務を持ちます（例：手牌の表示、ゲーム状況の表示）。
    - ユーザーからの入力を受け付け、Controllerに通知します。

- **Controller**: ModelとViewの橋渡し役を担当します。
    - `GameController` クラスを新設します。
    - `Main` クラスからゲームループのロジックを移動します。
    - `ConsoleView` と `Player`, `Table` などのモデルクラスをインスタンス化して保持します。
    - ユーザーからの入力を `ConsoleView` 経由で受け取り、それに応じて `Player` や `Table` の状態を変更するメソッドを呼び出します。
    - Modelの変更をViewに通知し、表示の更新を指示します。

### 3.3. リファクタリングの具体的なステップ

1. **パッケージの作成**: 上記で提案した新しいパッケージ (`controller`, `model`, `view`) を作成します。
2. **クラスの移動**: 既存のクラスを `model` パッケージに移動します。
3. **`ConsoleView` の作成**:
    - ユーザーに情報を表示するためのメソッド（例：`displayHand(List<TileType> hand)`, `promptForDiscard()`）を実装します。
    - ユーザーからの入力を受け取るメソッドを実装します。
4. **`GameController` の作成**:
    - `Main` クラスからゲームループのロジックを移動します。
    - `ConsoleView` と `Player`, `Table` などのモデルクラスをインスタンス化して保持します。
    - ユーザーからの入力を `ConsoleView` 経由で受け取り、それに応じて `Player` や `Table` の状態を変更するメソッドを呼び出します。
5. **`Player` と `Main` の修正**:
    - `Player` クラスからUIに関連するコード（`Scanner`や`System.out.println`）をすべて削除します。`discard` メソッドは、どの牌を捨てるかを引数で受け取るように変更します。
    - `Main` クラスは、`GameController` をインスタンス化してゲームを開始するだけのシンプルなクラスにします。

## 4. まとめ

提案したMVCアーキテクチャを導入することで、責務が明確に分離され、より柔軟で、テストやメンテナンスが容易なアプリケーションになります。これにより、将来的なGUIの導入や、新しいルールの追加といった機能拡張にもスムーズに対応できるようになります。
